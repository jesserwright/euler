// Each new term in the Fibonacci sequence is generated by adding
// the previous two terms. By starting with 1 and 2, the first 10 terms will be:

// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

// By considering the terms in the Fibonacci sequence whose values do not exceed
// four million, find the sum of the even-valued terms.

fn compute() -> i32 {
    Fibonacci::new()
        .take_while(|&f| f < 4_000_000)
        .filter(|&x| x % 2 == 0)
        .sum()
}

#[test]
fn prob2() {
    assert_eq!(compute(), 4613732);
}

struct Fibonacci {
    prev: i32,
    curr: i32,
    length: i32,
}

impl Fibonacci {
    fn new() -> Self {
        Fibonacci {
            prev: 1,
            curr: 2,
            length: 0,
        }
    }
}

impl Iterator for Fibonacci {
    type Item = i32;

    fn next(&mut self) -> Option<Self::Item> {
        self.length += 1;
        match self.length {
            1 => Some(1),
            2 => Some(2),
            _ => {
                let next = self.prev + self.curr;
                self.prev = self.curr;
                self.curr = next;
                Some(next)
            }
        }
    }
}

#[test]
fn fib_test() {
    let mut fib = Fibonacci::new(); // implement generic eventually
    assert_eq!(fib.next(), Some(1));
    assert_eq!(fib.next(), Some(2));
    assert_eq!(fib.next(), Some(3));
    assert_eq!(fib.next(), Some(5));
    assert_eq!(fib.next(), Some(8));
}
